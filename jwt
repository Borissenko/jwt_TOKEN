ЦЕЛЬ ТОКЕНА
-ОБЕСПЕЧИТЬ клиентские сеансы без сохранения состояния (на стороне сервера),
подтверждая авторизацию при запросах клиента.
Токен генерируется на сервере авторизации и храниться на клиенте.

https://gist.github.com/zmts/802dc9c3510d79fd40f9dc38a12bccfc
https://vc.ru/dev/106534-jwt-kak-bezopasnyy-sposob-autentifikacii-i-peredachi-dannyh - хор статья.

..............
КОДИРОВАНИЕ ТОКЕНА (сериализация)
- токен переводим в биты.

а)В несериализованном виде JWT состоит из заголовка и полезной нагрузки,
{
   "alg": "HS256"      //имя алгоритма шифрования.  "none"
}
{
iss: "https://auth-provider.domain.com/"    – издатель токена;
sub: "auth|some-hash-here"                  – описываемый объект;
aud: "unique-client-id-hash"                – получатели;
exp: 1529496683,                            – дата истечения срока действия;
iat – время создания.
}


б)Сериализованные токены - переведены в биты и имеют форму
[ Header ].[ Payload ].[ Signature ]

это делаем с помощью base64url (это не шифрование!).

function encode(h, p) {
   const header = base64UrlEncode(JSON.stringify(h));
   const payload = base64UrlEncode(JSON.stringify(p));
   return `${header}.${payload}`;
}
function decode(jwt) {
   const [headerB64, payloadB64] = jwt.split('.');
   const headerStr = base64UrlDecode(headerB64);
   const payloadStr = base64UrlDecode(payloadB64);
   return {
       header: JSON.parse(headerStr),
       payload: JSON.parse(payloadStr)
   };
}


............
БЕЗОПАСНОСТЬ

====ПОДПИСЬ - JSON Web Signature (JWS) 
-чтобы проверить, не были ли изменены данные.
А\\Самый распространенный алгоритм подписи – HMAC, схема с разделением секрета, поскольку секрет известен обеим сторонам.
создатель и получатель могут генерировать новое подписанное сообщение.


const SECRET_KEY = 'cAtwa1kkEy'
const unsignedToken = base64urlEncode(header) + '.' + base64urlEncode(payload)  \\кодирование, но это не шифрование(!).

const signature = HMAC-SHA256(unsignedToken, SECRET_KEY)

а токен будет представлять из себя
const token = encodeBase64Url(header) + '.' + encodeBase64Url(payload) + '.' + encodeBase64Url(signature)


Б\\Другой алгоритм подписи – RSASSA. Он позволяет принимающей стороне только проверять подлинность сообщения, но не генерировать его. 
Алгоритм основан на схеме открытого и закрытого ключей. 
Закрытый ключ - для создания подписи и для проверки. 
Открытый ключ - только для для проверки. 
Это удобно, где есть только один создатель сообщения и много получателей. 


=====ШИФРОВАНИЕ JWT - JSON Web Encryption (JWE).
Дополнительно к зашифрованному заголовку и полезной нагрузке сериализованный токен включает в себя 
- зашифрованный ключ, 
- вектор инициализации и 
- тег аутентификации.

Шифрование мб по двум криптографическим схемам:
А\\Схема разделенного секрета аналогична механизму подписки. Все стороны знают секрет и могут шифровать и дешифровать токен.
Токен- 3 секционный.

const jwt = require('jsonwebtoken');  //сразу кодирование, добавление подписи + шифрование
const secret = 'shhhhh';
const token = jwt.sign({ foo: 'bar' }, secret); // шифрование
const decoded = jwt.verify(token, secret);      // проверка и расшифровка
console.log(decoded.foo)                        // bar

//еще один вариант расшифровки токена на клиенте
  import jwtdecode from 'jwt-decode'
  const tokenData = jwtdecode(token) || {}    //тоже самое, что и decoded
  console.log('tokenData = ', tokenData)


Б\\схема закрытого и открытого ключей иная, чем используется для подписи.
открытый ключ - шифровать только, 
закрытый ключ - расшифровка только. 
Получается, что в этом случает JWE не может гарантировать подлинность токена. Чтобы иметь гарантию подлинности, следует использовать совмещать его с JWS.


======Refresh Token
- цель Refresh Token в том, чтобы получать новый короткоживущий базисный токен (access token) без новой Аутентифика́ции.


access token - используется для авторизации запросов и хранения дополнительной информации о пользователе (аля user_id, user_role - payload).
-Храним не в localStorage как это обычно делают, а в памяти клиентского приложения.
-короткоживущий (30 мин), но многоразовый.
-он для обращения на сервер-сайт, является Авториза́цией.


refresh token - выдается сервером по результам успешной аутентификации и используется для получения новой пары access/refresh токенов. 
-Храним в любом персистентном хранилище (persistere — упорствовать).
-Они долгоживущие (60 дней), но одноразовые.
-он для обращения на сервер-Аутентифика́ции.

refresh token в момент рефреша сравнивает себя с тем refresh token'ом который лежит в БД на сервере и вслучае успеха, а также если у него не истек срок, сервер рефрешит токены.



АЛГОРИТМ НА КЛИЕНТЕ
Пользователь логинится в приложении, передавая логин/пароль и fingerprint браузера (ну или некий иной уникальный индентификатор устройства если это не браузер)
Сервер проверят подлинность логина/пароля,
В случае удачи создает и записывает сессию в БД { userId: uuid, refreshToken: uuid, expiresIn: int, fingerprint: string, ... }
Отправляет клиенту два токена access и refresh token uuid (взятый из выше созданной сессии)
"accessToken": "eyJhbGciOiJIUzI1NiIs...",
"refreshToken": "9f34dd3a-ff8d-43aa-b286-9f22555319f6"
Клиент сохраняет токены(access в памяти приложения, refresh персистентно), используя access token для последующей авторизации запросов.

Перед каждым запросом клиент предварительно проверяет время жизни access token'а (да берем expires_in прямо из JWT в клиентском приложении) и если оно истекло использует refresh token чтобы обновить ОБА токена и продолжает использовать новый access token. Для большей уверенности можем обновлять токены на несколько секунд раньше.

==!
Библиотека для хеширования: https://github.com/Valve/fingerprintjs2
Более подробно: https://player.vimeo.com/video/151208427
Пример ф-ции получения такого хеша: https://gist.github.com/zmts/b26ba9a61aa0b93126fc6979e7338ca3


ОБЩАЯ СХЕМА
Клиент(фронтенд) проверяет перед запросом не истекло ли время жизни access token'на
Если истекло клиент отправляет на auth/refresh-token { refreshToken: uuid, fingerprint: string }
Сервер получает запись сессии по UUID'у рефреш токена
Cохраняет текущую сессию в переменную и удаляет ее из таблицы
Проверяет текущую сессию:
- Не истекло ли время жизни
- На соответствие старого fingerprint'a полученного из текущей сессии с новым полученным из тела запроса
В случае негативного результата бросает ошибку TOKEN_EXPIRED/INVALID_SESSION
В случае успеха создает новую сессию и записывает ее в БД
Создает новый access token
Отправляет клиенту { accessToken, refreshToken }.


....................
Пример имплементации:
Front-end

https://github.com/zmts/beauty-vuejs-boilerplate/blob/master/src/services/http.init.js
https://github.com/zmts/beauty-vuejs-boilerplate/blob/master/src/services/auth.service.js

Back-end:
https://github.com/zmts/supra-api-nodejs/tree/master/actions/auth






