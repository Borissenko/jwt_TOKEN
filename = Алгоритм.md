//https://habr.com/ru/post/423753/ - толково.
//https://xsltdev.ru/nodejs/tutorial/jwt/ - конкретно.
//https://gist.github.com/zmts/802dc9c3510d79fd40f9dc38a12bccfc - популярно.

#1. Аутентификация
##1.1. Посылаем Credentials.
- посылаем на api-сервис,
- используем только POST-запросы, никогда GET(в которых данные передаются не в теле запроса, а в открытую - в query).
- посылаем логин/паспорт и, желательно, fingerprint. 
Паспорт - в зашифрованном виде.

##1.2. Сервер генерирует AccessToken 
- содержит user-роль, которая ограничивает объем доступа к данным,
- подпись шифруем через секретный ключ (секретный ключ храниться только на сервере).
- используется многократно для авторизации.
   

##1.3. Сервер генерирует RefreshToken 
- используется однократно для обновления просроченного AccessToken'a.

##1.4. Сервер формирует токен-сессию и записывает ее в БД 
{ 
userId: uuid, 
fingerprint: string, 
refreshToken: uuid, 
expiresIn: int 
}



#2. Что куда возвращаем в результате Аутентификации.
##1. Пароль
a) на клиенте
- никогда не хранится,
- должен быть немедленно УДАЛЕН из data() после отправки в API для Аутентификации.

b) на сервере
- храним в данных юзера


##2. AccessToken
a) на клиенте
-храним исключительно в Vue-проекте.
Но не в глобальной переменной аля window.accessToken, а в ЗАМЫКАНИИ(!), никогда не сохраняется в долговременную память ноутбука клиента.
Далее используем для авторизации, помещая AccessToken в header запроса - 

options.headers.Authorization = `Bearer ${token}`;

Хакер не способен сымитировать AccessToken, т.к. он не знает ключа для генерации валидной подписи.
Хакер может лишь украсть родной AccessToken, но хакер сможет работать от лица клиента не дольше 30мин.

Поэтому срок жизни AccessToken ставим примерно такое же, как время работы клиента на сайте, не более.
Если хакер сворует AccessToken во время работы основного юзера, то у юзера слетит авторизация (запрос от хакера пойдет с иным fingerprint'ом).
Юзер перезалогиниться, и хакер потеряет доступ.
Но ОДИН запрос от лица юзера хакер все же успеет сделать. )))


b) на сервере
- в данных юзера.
Далее серверный экземпляр AccessToken'a используем для проверки предъявляемого AccessToken'а.


##b) RefreshToken
a) на клиенте
- сохраняем на клиенте в долговременной памяти - куки броузера, Не в оперативной памяти.
- только в зашифрованном виде.

Инициализируем куку, указав в ответе сервера
Set-Cookie: refreshToken='c84f18a2-c6c7-4850-be15-93f9cbaef3b3'; HttpOnly; SameSite=Strict; domain: '.super.com'; path: '/api/auth'
или
via cookieParser в коде сервера.

Обязательные параметры для куки с RefreshToken'ом:
{
HttpOnly;
SameSite=Strict;
domain: '.super.com',
path: '/api/auth/login, /api/auth/refresh-tokens, /api/auth/logout',    // адреса эндпоинтов аутентификации.
max-age=3600
}

b) на сервере
- в данных юзера,
- для учета доступа и отсеивания краденых токенов.

При получении RefreshToken'a мы его проверяем
- что это непросроченный RefreshToken,
- что это ПОСЛЕДНИЙ из выданных.
Далее используем для рефреша AccessToken'a.
 





#3. Авторизация.
- В хедер ОПРЕДЕЛЕННЫХ запросов добавляем поле Authorization с AccessToken'ом.
- Запросы направляем непосредственно на auth-сервис(!) через nginx(!).
- используем только POST-запросы.
Будет отрабатывать хедер с AccessToken'ом.
При просроченности AccessToken'a будет отрабатывать кука с RefreshToken'ом.
  

##3.1. Проверка AccessToken'а.
- проверяем expires (дата годности) AccessToken'а, который мы получаем их header'a запроса.
- проверяем отсутствие деформаций у токена. 
На основе НЕЗАШИФРОВАННЫХ header & pl токена повторно создаем подпись (опираясь на ключ),
и далее сравниваем полученную подпись с подписью из токена.


При попытке хакером ПОДМЕНИТЬ данные в header'ре или payload'е токена, токен станет невалидным,
т.к. сигнатура не будет соответствовать изначальным значениям.
А возможность сгенерировать новую сигнатуру у хакера отсутствует, поскольку секретный ключ для зашифровки лежит на сервере.

Хакер может СВОРОВАТЬ AccessToken, не изменяя его,
но хозяйничать от лица юзера он сможет всего 30 мин.




#4. Пролонгация токена.
- В куках ВСЕХ запросов присутствует RefreshToken,
но, ввиду наличия у куки прописанного andpoint'a,
эта кука будет всплывать только в ОПРЕДЕЛЕННЫХ запросах(куках запроса), что и AccessToken(в хедере запроса).

- При просроченности AccessToken'а (из header'a) 
залезаем в куки зарпоса
достаем куку RefreshToken
проверяем куку на просроченность
проверяем RefreshToken на актуальность, сравнивая с серверным экземпляром

Генерируем новый AccessToken и RefreshToken.




#5. axios для отправки запроса с куками имеет опцию { withCredentials: true }



#6. Удаление куки
res.clearCookie() - удаляет по заданному ключу значение у клиента, если ключ не задан - удаляет все.
