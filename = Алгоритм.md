//https://habr.com/ru/post/423753/ - толково.
//https://xsltdev.ru/nodejs/tutorial/jwt/ - конкретно.
//https://gist.github.com/zmts/802dc9c3510d79fd40f9dc38a12bccfc - популярно.

https://qna.habr.com/q/519691 - круто!

#1. Аутентификация
##1.1. Посылаем Credentials(логин, паспорт, fingerprint).
- посылаем на api-сервис, (Ут ???)
- используем ТОЛЬКО POST-запросы, никогда GET(в GET данные передаются не в теле запроса, а в открытую - в query).
- посылаем логин/паспорт и, желательно, fingerprint. 
Паспорт - в зашифрованном виде.

##1.2. Сервер генерирует AccessToken 
- содержит user-роль, которая ограничивает объем доступа к данным,
- подпись шифруем через секретный ключ (секретный ключ храниться только на сервере).
- используется многократно для авторизации.
- хранитьсяна клиенте в замыкании в store проекта. 
   

##1.3. Сервер генерирует RefreshToken 
- используется однократно для обновления просроченного AccessToken'a.
- храниться в куках броузера.

##1.4. Хранение токенов на сервере
Сервер формирует токен-сессию и записывает ее в БД 
{ 
userId: uuid, 
fingerprint: string, 
refreshToken: uuid, 
expiresIn: int 
}



#2. Что куда возвращаем в результате Аутентификации.
##1. Пароль
a) на клиенте
- никогда не хранится,
- должен быть немедленно УДАЛЕН из data() после отправки в API для Аутентификации.

b) на сервере
- храним в данных юзера


##2. AccessToken
a) на клиенте
-храним исключительно в Vue-проекте, в store, в замыкании.
Но не в глобальной переменной аля window.accessToken, а в ЗАМЫКАНИИ(!), никогда не сохраняется в долговременную память ноутбука клиента.

Далее используем для авторизации, помещая AccessToken в header запроса - 
options.headers.Authorization = `Bearer ${token}`

Хакер не способен сымитировать AccessToken, т.к. он не знает ключа для генерации валидной подписи.
Хакер может лишь украсть родной AccessToken, но в этом случае хакер сможет работать от лица клиента не дольше 30мин - время жизни AccessToken'a.

Поэтому срок жизни AccessToken ставим примерно такое же, как время средней работы клиента на сайте, не более.
Если хакер сворует AccessToken во время работы основного юзера, то у юзера слетит авторизация (запрос от хакера пойдет с иным fingerprint'ом).
Юзер перезалогиниться, и хакер вновь потеряет доступ.
Но минимум ОДИН запрос от лица юзера хакер все же успеет сделать. )))


b) на сервере
- в данных юзера.
Далее серверный экземпляр AccessToken'a используем для проверки предъявляемого AccessToken'а.


##b) RefreshToken
a) RefreshToken на клиенте
- сохраняем на клиенте в долговременной памяти - куки броузера, Не в оперативной памяти.
- сохраняем только в зашифрованном виде.

### Инициализируем RefreshToken-куку, 
уИнициализируем, казав в ответе сервера
Set-Cookie: refreshToken='c84f18a2-c6c7-4850-be15-93f9cbaef3b3'; HttpOnly; SameSite=Strict; domain: '.super.com'; path: '/api/auth'
или 
via cookieParser в коде сервера:
app.use(cookieParser('demoProject'))

res.cookie('refreshToken', data.refreshToken, {
  // maxAge: 3600000 * 24,                                // 3600000ms * 24 = 24 часа
  expires: new Date(Date.now() + 86400000),         //формат 2021-03-25T09:53:13.067Z
  httpOnly: true,
  secure: true,
  sameSite: 'Strict',
  // path: '/api/authentication'     //or '/authentication' ???
})

### Обязательные параметры для RefreshToken-куки:
{
HttpOnly;
SameSite=Strict;
domain: '.super.com',
path: '/api/auth/login, /api/auth/refresh-tokens, /api/auth/logout',    // адреса эндпоинтов аутентификации.
max-age=3600
}

b) RefreshToken на сервере
- сохраняем в данных юзера,
- сохраняем для учета доступа и отсеивания краденых токенов.

При получении RefreshToken'a мы его проверяем
- что это непросроченный RefreshToken,
- что это ПОСЛЕДНИЙ из выданных.
Далее используем для рефреша AccessToken'a.
 





#3. Авторизация.
- В ХЕАДЕР у ОПРЕДЕЛЕННЫХ запросов добавляем ПОЛЕ Authorization с AccessToken'ом.
AccessToken прикрепляется в header запроса, как ПОЛЕ хедера (не в виде куки, прописанной в хеадере)-

options.headers.Authorization = `Bearer ${token}`
  
- Запросы направляем непосредственно на auth-сервис(!) через nginx(!).
- используем только POST-запросы(!).

Будет отрабатывать =хедер с AccessToken'ом=.
При просроченности AccessToken'a будет отрабатывать =кука с RefreshToken'ом=.




##3.1. Проверка AccessToken'а.
- проверяем expires (дата годности) AccessToken'а (AccessToken получаем их header'a запроса).
- проверяем отсутствие деформаций у токена. 
На основе НЕЗАШИФРОВАННЫХ header & pl токена повторно создаем подпись (опираясь на ключ),
и далее сравниваем полученную подпись с подписью из токена.


При попытке хакером ПОДМЕНИТЬ данные в header'ре или payload'е токена, токен станет невалидным,
т.к. сигнатура не будет соответствовать изначальным значениям.
А возможность сгенерировать новую сигнатуру у хакера отсутствует, поскольку секретный ключ для зашифровки лежит на сервере.

Хакер может СВОРОВАТЬ AccessToken, не изменяя его,
но хозяйничать от лица юзера он сможет всего 30 мин - время валидности токена.




##3.2. ПОСЛЕДУЮЩАЯ Авторизация при всех последующих от Аутентификации запросов
- Добавление AccessToken'a в хеадер запросов в виде ПОЛЯ хеадера
Это НЕ делаем глобально, т.к. AccessToken изменяется в процессе работы с сайтом.
Хеадер добавляем для каждого axios-запроса индивидуально.



#4. Пролонгация токена.
- В куках ВСЕХ запросов присутствует RefreshToken,
но, ввиду наличия у куки прописанного andpoint'a,
эта кука будет всплывать только в ОПРЕДЕЛЕННЫХ запросах(куках запроса), что и AccessToken(в хедере запроса).

- При просроченности AccessToken'а (из header'a) 
залезаем в куки зарпоса
достаем куку RefreshToken
проверяем куку на просроченность
проверяем RefreshToken на актуальность, сравнивая с серверным экземпляром

Генерируем новый AccessToken и RefreshToken.




#5. axios для отправки запроса с куками имеет опцию { withCredentials: true }



#6. Удаление куки
res.clearCookie() - удаляет по заданному ключу значение у клиента, если ключ не задан - удаляет все.
